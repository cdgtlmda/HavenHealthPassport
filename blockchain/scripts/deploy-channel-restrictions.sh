#!/bin/bash

# Deploy Channel Restrictions Configuration
# Haven Health Passport - Multi-Channel Management

set -euo pipefail

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Configuration
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
CONFIG_FILE="${SCRIPT_DIR}/../config/consensus/channel-restrictions-config.yaml"
ORDERER_CONFIG="${SCRIPT_DIR}/../config/consensus/ordering-service-config.yaml"
AWS_REGION="${AWS_REGION:-us-east-1}"
NETWORK_ID="${HAVEN_BLOCKCHAIN_NETWORK_ID}"

# Logging functions
log_info() { echo -e "${GREEN}[INFO]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"; }
log_section() { echo -e "\n${BLUE}=== $1 ===${NC}"; }

# Validate configuration
validate_config() {
    log_section "Validating Channel Restrictions Configuration"

    # Check file exists
    if [ ! -f "${CONFIG_FILE}" ]; then
        log_error "Configuration file not found: ${CONFIG_FILE}"
        exit 1
    fi

    # Validate YAML
    if ! yq eval '.' "${CONFIG_FILE}" > /dev/null 2>&1; then
        log_error "Invalid YAML in configuration file"
        exit 1
    fi

    # Check required sections
    local required_sections=("global" "channelCategories" "ordererRestrictions" "resourceAllocation")
    for section in "${required_sections[@]}"; do
        if [ -z "$(yq eval ".channelRestrictions.${section}" "${CONFIG_FILE}")" ]; then
            log_error "Missing required section: ${section}"
            exit 1
        fi
    done

    log_info "Configuration validation passed"
}

# Apply orderer restrictions
apply_orderer_restrictions() {
    log_section "Applying Orderer Channel Restrictions"

    # For each orderer, generate restriction configuration
    yq eval '.channelRestrictions.ordererRestrictions.ordererAssignments | keys | .[]' "${CONFIG_FILE}" | while read -r orderer; do
        log_info "Configuring restrictions for ${orderer}"

        local required=$(yq eval ".channelRestrictions.ordererRestrictions.ordererAssignments[\"${orderer}\"].required[]" "${CONFIG_FILE}" 2>/dev/null | paste -sd, -)
        local allowed=$(yq eval ".channelRestrictions.ordererRestrictions.ordererAssignments[\"${orderer}\"].allowed[]" "${CONFIG_FILE}" 2>/dev/null | paste -sd, -)
        local prohibited=$(yq eval ".channelRestrictions.ordererRestrictions.ordererAssignments[\"${orderer}\"].prohibited[]" "${CONFIG_FILE}" 2>/dev/null | paste -sd, -)
        local max_channels=$(yq eval ".channelRestrictions.ordererRestrictions.ordererAssignments[\"${orderer}\"].maxChannels" "${CONFIG_FILE}")

        # Create orderer-specific configuration
        cat > "${SCRIPT_DIR}/../config/consensus/orderer-restrictions-${orderer}.yaml" <<EOF
# Channel Restrictions for ${orderer}
# Generated by deploy-channel-restrictions.sh

orderer:
  name: ${orderer}
  channelRestrictions:
    required: [${required}]
    allowed: [${allowed}]
    prohibited: [${prohibited}]
    maxChannels: ${max_channels}

  resourceLimits:
    maxCPUPercent: 80
    maxMemoryGB: 32
    maxStorageGB: 1000
    maxNetworkMbps: 1000
EOF

        log_info "Restrictions configured for ${orderer}"
    done
}

# Create channel policies
create_channel_policies() {
    log_section "Creating Channel Category Policies"

    # For each channel category
    yq eval '.channelRestrictions.channelCategories | keys | .[]' "${CONFIG_FILE}" | while read -r category; do
        log_info "Creating policies for ${category} channels"

        local patterns=$(yq eval ".channelRestrictions.channelCategories.${category}.patterns[]" "${CONFIG_FILE}" | paste -sd, -)
        local creation_policy=$(yq eval ".channelRestrictions.channelCategories.${category}.restrictions.creationPolicy" "${CONFIG_FILE}")
        local priority=$(yq eval ".channelRestrictions.channelCategories.${category}.restrictions.resources.priorityClass" "${CONFIG_FILE}")

        # Create policy configuration
        cat > "${SCRIPT_DIR}/../config/consensus/channel-policy-${category}.json" <<EOF
{
  "category": "${category}",
  "patterns": [$(echo "${patterns}" | sed 's/,/","/g' | sed 's/^/"/;s/$/"/')],
  "policies": {
    "Readers": {
      "Type": "ImplicitMeta",
      "Rule": "ANY Readers"
    },
    "Writers": {
      "Type": "ImplicitMeta",
      "Rule": "ANY Writers"
    },
    "Admins": {
      "Type": "Signature",
      "Rule": "${creation_policy}"
    }
  },
  "capabilities": {
    "V2_0": true
  },
  "resources": {
    "priority": "${priority}"
  }
}
EOF

        log_info "Policy created for ${category} channels"
    done
}

# Setup resource quotas
setup_resource_quotas() {
    log_section "Setting Up Resource Quotas"

    # For each QoS class
    yq eval '.channelRestrictions.resourceAllocation.qosClasses | keys | .[]' "${CONFIG_FILE}" | while read -r qos_class; do
        log_info "Configuring ${qos_class} QoS class"

        local cpu=$(yq eval ".channelRestrictions.resourceAllocation.qosClasses.${qos_class}.guarantees.cpuPercent" "${CONFIG_FILE}")
        local memory=$(yq eval ".channelRestrictions.resourceAllocation.qosClasses.${qos_class}.guarantees.memoryPercent" "${CONFIG_FILE}")
        local iops=$(yq eval ".channelRestrictions.resourceAllocation.qosClasses.${qos_class}.guarantees.diskIOPS" "${CONFIG_FILE}")
        local bandwidth=$(yq eval ".channelRestrictions.resourceAllocation.qosClasses.${qos_class}.guarantees.networkBandwidthMbps" "${CONFIG_FILE}")

        # Create Kubernetes ResourceQuota if using K8s
        if command -v kubectl &> /dev/null; then
            cat > "/tmp/resource-quota-${qos_class}.yaml" <<EOF
apiVersion: v1
kind: ResourceQuota
metadata:
  name: channel-quota-${qos_class}
  namespace: blockchain
spec:
  hard:
    requests.cpu: "${cpu}"
    requests.memory: "${memory}Gi"
    persistentvolumeclaims: "10"
    requests.storage: "1Ti"
EOF

            kubectl apply -f "/tmp/resource-quota-${qos_class}.yaml" || log_warn "Failed to apply K8s quota"
        fi

        # Create AWS resource tags for tracking
        aws resourcegroupstaggingapi tag-resources \
            --resource-arn-list "arn:aws:managedblockchain:${AWS_REGION}:*:networks/${NETWORK_ID}" \
            --tags "QoSClass=${qos_class},CPUPercent=${cpu},MemoryPercent=${memory}" \
            --region "${AWS_REGION}" || true
    done
}

# Configure monitoring
configure_monitoring() {
    log_section "Configuring Channel Monitoring"

    # Create CloudWatch dashboard
    local dashboard_name="HavenHealth-ChannelRestrictions"
    local dashboard_body=$(cat <<EOF
{
  "widgets": [
    {
      "type": "metric",
      "properties": {
        "metrics": [
          [ "HavenHealth/Blockchain", "ChannelCount", { "stat": "Sum" } ],
          [ ".", "TransactionRate", { "stat": "Average" } ],
          [ ".", "StorageUsed", { "stat": "Sum" } ],
          [ ".", "ResourceUtilization", { "stat": "Average" } ]
        ],
        "period": 300,
        "stat": "Average",
        "region": "${AWS_REGION}",
        "title": "Channel Metrics"
      }
    }
  ]
}
EOF
)

    aws cloudwatch put-dashboard \
        --dashboard-name "${dashboard_name}" \
        --dashboard-body "${dashboard_body}" \
        --region "${AWS_REGION}" || log_warn "Failed to create dashboard"

    # Create alarms
    yq eval '.channelRestrictions.monitoring.alerts[]' "${CONFIG_FILE}" -o=j | while IFS= read -r alert; do
        local name=$(echo "${alert}" | jq -r '.name')
        local condition=$(echo "${alert}" | jq -r '.condition')
        local severity=$(echo "${alert}" | jq -r '.severity')

        log_info "Creating alarm: ${name}"

        # Create CloudWatch alarm (simplified)
        aws cloudwatch put-metric-alarm \
            --alarm-name "ChannelRestriction-${name}" \
            --alarm-description "Channel restriction alert: ${condition}" \
            --metric-name "ChannelViolations" \
            --namespace "HavenHealth/Blockchain" \
            --statistic "Sum" \
            --period 300 \
            --threshold 1 \
            --comparison-operator "GreaterThanOrEqualToThreshold" \
            --evaluation-periods 1 \
            --region "${AWS_REGION}" || true
    done
}

# Apply configuration to blockchain network
apply_to_network() {
    log_section "Applying Configuration to Blockchain Network"

    # Update orderer configuration
    log_info "Updating orderer configuration"

    # Add channel restrictions reference to main config
    yq eval ".orderingService.channelRestrictions = \"./channel-restrictions-config.yaml\"" \
        "${ORDERER_CONFIG}" > "${ORDERER_CONFIG}.tmp"
    mv "${ORDERER_CONFIG}.tmp" "${ORDERER_CONFIG}"

    # For each orderer, apply restrictions
    yq eval '.channelRestrictions.ordererRestrictions.ordererAssignments | keys | .[]' "${CONFIG_FILE}" | while read -r orderer; do
        log_info "Applying restrictions to ${orderer}"

        # In production, this would update the orderer's configuration
        # Here we create the configuration files that would be applied
        local config_file="${SCRIPT_DIR}/../config/consensus/orderer-restrictions-${orderer}.yaml"

        if [ -f "${config_file}" ]; then
            log_info "Configuration ready for ${orderer}: ${config_file}"
        fi
    done
}

# Generate deployment report
generate_report() {
    log_section "Generating Deployment Report"

    local report_file="${SCRIPT_DIR}/../config/consensus/channel-restrictions-deployment-$(date +%Y%m%d-%H%M%S).txt"

    cat > "${report_file}" <<EOF
Haven Health Passport - Channel Restrictions Deployment Report
============================================================

Deployment Date: $(date)
Configuration: ${CONFIG_FILE}

Channel Categories Configured:
-----------------------------
EOF

    yq eval '.channelRestrictions.channelCategories | keys | .[]' "${CONFIG_FILE}" | while read -r category; do
        local patterns=$(yq eval ".channelRestrictions.channelCategories.${category}.patterns[]" "${CONFIG_FILE}" | paste -sd, -)
        echo "- ${category}: ${patterns}" >> "${report_file}"
    done

    cat >> "${report_file}" <<EOF

Orderer Assignments:
-------------------
EOF

    yq eval '.channelRestrictions.ordererRestrictions.ordererAssignments | keys | .[]' "${CONFIG_FILE}" | while read -r orderer; do
        local max_channels=$(yq eval ".channelRestrictions.ordererRestrictions.ordererAssignments[\"${orderer}\"].maxChannels" "${CONFIG_FILE}")
        echo "- ${orderer}: Max ${max_channels} channels" >> "${report_file}"
    done

    cat >> "${report_file}" <<EOF

Resource QoS Classes:
--------------------
- Critical: 40% CPU, 40% Memory
- High: 30% CPU, 30% Memory
- Normal: 20% CPU, 20% Memory
- Low: 10% CPU, 10% Memory

Monitoring:
-----------
- CloudWatch Dashboard: HavenHealth-ChannelRestrictions
- Alarms Configured: $(yq eval '.channelRestrictions.monitoring.alerts | length' "${CONFIG_FILE}")

Next Steps:
-----------
1. Review generated orderer restriction files
2. Apply configurations to running orderers
3. Test channel creation with new restrictions
4. Monitor resource usage and adjust quotas
5. Verify compliance requirements are met

EOF

    log_info "Deployment report generated: ${report_file}"
}

# Main execution
main() {
    log_info "Starting channel restrictions deployment"

    validate_config
    apply_orderer_restrictions
    create_channel_policies
    setup_resource_quotas
    configure_monitoring
    apply_to_network
    generate_report

    log_info "Channel restrictions deployment completed successfully!"
}

# Run main function
main "$@"
